Delivered-To: alexis.jawtuschenko@gmail.com
Received: by 10.220.164.19 with SMTP id c19cs170785vcy;
        Tue, 14 Sep 2010 13:27:51 -0700 (PDT)
Received: by 10.213.33.84 with SMTP id g20mr3222039ebd.4.1284495357988;
        Tue, 14 Sep 2010 13:15:57 -0700 (PDT)
Received-SPF: softfail (google.com: best guess record for domain of transitioning ic-alu-bounces@dc.uba.ar does not designate 157.92.27.61 as permitted sender) client-ip=157.92.27.61;
Received: by 10.208.8.6 with POP3 id 6mf900350eyh.22;
        Tue, 14 Sep 2010 13:15:57 -0700 (PDT)
X-Gmail-Fetch-Info: alexis_bj@hotmail.com 1 pop3.live.com 995 alexis_bj@hotmail.com
X-Message-Delivery: Vj0zLjQuMDt1cz0wO2k9MDtsPTA7YT0x
X-Message-Status: n:0
X-SID-PRA: ic-alu-bounces@dc.uba.ar
X-Message-Info: JGTYoYF78jGRMYpPXOkO9MWw+iBFWM54jBpkbkahdo5y98NbHvKc7vJo/6105WsggEYStw5TuKatUs3qLYx6vQ==
Received: from smtp-1.dc.uba.ar ([157.92.27.61]) by bay0-mc8-f22.bay0.hotmail.com with Microsoft SMTPSVC(6.0.3790.2668);
	 Sun, 25 May 2008 16:30:30 -0700
Received: (qmail 10048 invoked from network); 25 May 2008 23:30:28 -0000
Received: from unknown (HELO listas.dc.uba.ar) ([10.0.0.31])
          (envelope-sender <ic-alu-bounces@dc.uba.ar>)
          by smtp-1.dc.uba.ar (qmail-ldap-1.03) with compressed SMTP
          for <alexis_bj@hotmail.com>; 25 May 2008 23:30:28 -0000
Received: (qmail 7628 invoked from network); 25 May 2008 23:30:28 -0000
Received: from unknown (HELO [127.0.0.1]) ([127.0.0.1])
          (envelope-sender <ic-alu-bounces@dc.uba.ar>)
          by listas.dc.uba.ar (qmail-ldap-1.03) with SMTP
          for <el_tatu_carreta@hotmail.com>; 25 May 2008 23:30:28 -0000
Received: (qmail 7622 invoked from network); 25 May 2008 23:30:27 -0000
Received: from unknown ([10.0.0.62])
	by listas.dc.uba.ar (qmail-ldap-1.03) with QMQP;
	25 May 2008 23:30:27 -0000
Delivered-To: CLUSTERHOST smtp-2.dc.uba.ar ic-alu@dc.uba.ar
Received: (qmail 27945 invoked by uid 111); 25 May 2008 23:30:27 -0000
Received: from 200.126.220.20 by athila-2 (envelope-from <dgorin@dc.uba.ar>,
	uid 1002) with qmail-scanner-1.25 (spamassassin: 3.0.4.  
	Clear:RC:0(200.126.220.20):SA:0(-1.2/3.5):. 
	Processed in 4.080864 secs); 25 May 2008 23:30:27 -0000
X-Spam-Checker-Version: SpamAssassin 3.1.4 (2006-07-26) on athila-2
X-Spam-Level: 
X-Spam-Status: No, score=-1.2 required=3.5 tests=ALL_TRUSTED, AWL,
	FUZZY_AMBIEN autolearn=no version=3.1.4
X-Envelope-From: dgorin@dc.uba.ar
Received: from unknown (HELO [192.168.1.2]) (dgorin@[200.126.220.20])
	(envelope-sender <dgorin@dc.uba.ar>)
	by smtp-2.dc.uba.ar (qmail-ldap-1.03) with AES128-SHA encrypted SMTP
	for <ic-alu@dc.uba.ar>; 25 May 2008 23:30:23 -0000
Mime-Version: 1.0 (Apple Message framework v753)
Message-Id: <D2C56AE8-EB05-459A-B886-5C0CB14F78E6@dc.uba.ar>
To: ic-alu@dc.uba.ar
From: =?ISO-8859-1?Q?Daniel_Gor=EDn?= <dgorin@dc.uba.ar>
Date: Sun, 25 May 2008 20:30:15 -0300
X-Mailer: Apple Mail (2.753)
Subject: [ic-alu] consulta frecuente sobre el TP3 (IMPORTANTE!)
X-BeenThere: ic-alu@dc.uba.ar
X-Mailman-Version: 2.1.9
Precedence: list
List-Id: =?iso-8859-1?q?Lista_de_alumnos_de_la_materia_Introducci=F3n_a_la_Computaci=F3n?=
	<ic-alu.dc.uba.ar>
List-Unsubscribe: <https://listas.dc.uba.ar/cgi-bin/mailman/listinfo/ic-alu>, 
	<mailto:ic-alu-request@dc.uba.ar?subject=unsubscribe>
List-Archive: <http://listas.dc.uba.ar/pipermail/ic-alu>
List-Post: <mailto:ic-alu@dc.uba.ar>
List-Help: <mailto:ic-alu-request@dc.uba.ar?subject=help>
List-Subscribe: <https://listas.dc.uba.ar/cgi-bin/mailman/listinfo/ic-alu>,
	<mailto:ic-alu-request@dc.uba.ar?subject=subscribe>
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Sender: ic-alu-bounces@dc.uba.ar
Errors-To: ic-alu-bounces@dc.uba.ar
Return-Path: ic-alu-bounces@dc.uba.ar
X-OriginalArrivalTime: 25 May 2008 23:30:31.0606 (UTC) FILETIME=[52BABD60:01C8BEBF]

Buenas

Respondemos a todos una consulta frecuente. El mail es un poco largo,  =

pero esperamos que se entienda!

A muchos les est=E1 pasando que cuando quieren hacer un "getline" como  =

figura en el apunte que mand=F3 Luis, no pasa nada. O sea, no se queda  =

esperando a que escriban algo, sino que sigue de largo. Para entender  =

qu=E9 est=E1 pasando, tenemos que entender un poco mejor c=F3mo trabaja el  =

cin...

cin es una variable de un tipo llamado "istream" (input stream). La  =

idea de este tipo es que representa la entrada del usuario como una  =

"secuencia de caracteres". Operaciones como como >> toman caracteres  =

que est=E1n en la secuencia y tratan de interpretarlos apropiadamente.  =

Cuando la secuencia queda vac=EDa, sucede que el programa se detiene y  =

se queda esperando que el usuario ingrese m=E1s datos.

Tratemos de entender esto mejor con un ejemplo. Consideren el  =

siguiente programa:

prog1.cpp:

#include <iostream>
using namespace std;

int main() {
   int i, j;
   cin >> i;
   cin >> j;
   cout >> (i+j);
   return 0;
}

si se ejecuta prog1, cin inicialmente representa una secuencia vac=EDa.  =

cuando la ejecuci=F3n llega a "cin >> i", para poder resolver esto,  =

hace falta esperar a que el usuario escriba algo. Por eso es que en  =

ese caso ver=EDan el cursos titilando, como esperando.

Ahora, supongamos que el usuario ingresa lo siguiente:

1234 377<enter>

(el =FAltimo <enter> representa que apret=F3 enter).

En ese momento, cin es la secuencia de caracteres:

['1', '2', '3', 4', ' ', '3', '7', '7', '\n']

El ' ' es el caracter asociado al "espacio en blanco", mientras que  =

el '\n' es un caracter asociado al enter.

Ahora se puede resolver el "cin >> i". Qu=E9 es lo que hace? Toma todos  =

los caracteres iniciales que representen un d=EDgito y con eso calcula  =

el valor para i. O sea, deja un 1234 en i. Lo importante es que ahora  =

cin es la secuencia:

[' ', '3', '7', '7', '\n']

Es decir, el operador >> "consumi=F3" todos los caracteres que pudo y  =

en cuanto encontr=F3 el primero que no era un d=EDgito (en este caso, el  =

' '), par=F3 ah=ED. El resto de los caracteres que est=E1n en la secuencia  =

no fueron consumidos.

Acto seguido, se debe ejecutar el "cin >> j". A diferencia del caso  =

anterior, ahora cin no est=E1 vac=EDo con lo cual no hace falta esperar a  =

que el usuario ingrese algo. El operador >> va a ignorar todos los  =

caracteres que representen espacios que haya adelante de todo (esto  =

tambi=E9n lo hizo en el caso anterior, s=F3lo que no hab=EDa ninguno),  =

despu=E9s va a procesar todos los caracteres que representen d=EDgitos y,  =

finalmente, va a parar en cuanto encuentre el primero que no lo es.  =

Es decir, en j va a quedar un 377, y cin va a quedar as=ED:

['\n']

El programa finalmente calcula i+j, lo muestra y termina. Pero lo que  =

queremos observar es que, llegado este punto, cin no representaba una  =

secuencia vac=EDa!

Consideremos ahora el siguiente programa:

prog2.cpp:

#include <iostream>
#include <string>
using namespace std;

int main() {
   string s;
   getline(cin, s);
   cout >> s;
   return 0;
}

Si ahora corremos prog2, va a pasar lo siguiente. Primero, cin es la  =

secuencia vac=EDa. Cuando se quiere hacer el getline, el programa se  =

queda esperando que el usuario ingrese caracteres en la secuencia.  =

Supongamos que ingresa

hola, fonola<enter>

En ese momento tenemos que cin es:

['h', 'o', 'l', 'a', ', ', ' ', 'f', 'o', 'n', 'o', 'l', 'a', '\n']

Lo que hace el getline es procesar todos los caracteres hasta  =

encontrar el primer '\n', y con todo eso (salvo el '\n') se da un  =

valor a s (en este caso "hola, fonola"). El '\n' se elimina de la  =

secuencia. Con lo cual, al terminar el programa, cin es una secuencia  =

vac=EDa.

Finalmente, consideremos este ejemplo; similar al que les trae  =

problemas con el tp:

prog3.cpp:

#include <iostream>
#include <string>
using namespace std;

int main() {
   int i;
   cin >> i;

   string s;
   getline(cin, s);

   cout s >> i;

   return 0;
}

Miremos lo que pasa ac=E1. Al ejecutar el "cin >> i", el programa  =

espera a que el usuario ingrese algo (porque cin es una secuencia  =

vac=EDa). Supongamos que el usuario ingresa:

1274<enter>

En ese caso, tenemos que cin es la secuencia:

['1', '2', '7', '4', '\n']

Pero al procesar el operador >> los cuatro primeros caracteres se  =

consumen, i queda valiendo 1274 y cin queda como la secuencia:

['\n']

Ahora bien, cuando llega la hora de ejecutar el "getline(cin, s)",  =

cin no es una secuencia vac=EDa! Lo que va a hacer el getline en este  =

caso es dejar en s un string de longitud cero, consumir el '\n' y  =

seguir adelante. Comparen esto con lo que pasaba en prog2...

Entonces, c=F3mo se puede solucionar esto? Una cosa f=E1cil que pueden  =

hacer es, despu=E9s de leer un int (e.g., la opci=F3n ingresada por el  =

usuario) hacer que se "ignore" todo lo que haya quedado en cin. Por  =

ejemplo, as=ED:

prog4.cpp:

#include <iostream>
#include <string>
using namespace std;

int leerEnteroIgnorarResto() {
   int i;
   cin >> i;

   // el resto de la l=EDnea lo leemos y despu=E9s lo ignoramos
   string el_resto;
   getline(cin, el_resto);

   return i;
}

int main () {
   int i =3D leerEnteroIgnorarResto();

   string s;
   getline(cin, s);

   cout >> s >> i;
}

Este deber=EDa funcionar como quer=EDamos! Cualquier duda, chiflen...

Saludos
Daniel

pd: El c=F3digo no est=E1 probado, puede no compilar!
_______________________________________________
ic-alu mailing list
ic-alu@dc.uba.ar
https://listas.dc.uba.ar/cgi-bin/mailman/listinfo/ic-alu

